<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="1. 使用线程的方式1.1 继承Thread类">
<meta name="keywords" content="JAVA">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA并发">
<meta property="og:url" content="http://yoursite.com/2020/03/06/JAVA并发/index.html">
<meta property="og:site_name" content="经常咕咕的菜鸡博客">
<meta property="og:description" content="1. 使用线程的方式1.1 继承Thread类">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/1.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/2.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/4.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/3.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/5.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/6.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/7.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/8.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/9.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/10.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/11.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/12.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/13.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JAVA并发/14.png">
<meta property="og:updated_time" content="2020-03-09T09:53:08.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA并发">
<meta name="twitter:description" content="1. 使用线程的方式1.1 继承Thread类">
<meta name="twitter:image" content="http://yoursite.com/2020/03/06/JAVA并发/1.png">
  <link rel="canonical" href="http://yoursite.com/2020/03/06/JAVA并发/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JAVA并发 | 经常咕咕的菜鸡博客</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">经常咕咕的菜鸡博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>文章</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    
    <div class="reading-progress-bar"></div>

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/06/JAVA并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="经常咕咕的菜鸡博客">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/QQ图片20200223231821.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="经常咕咕的菜鸡博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">JAVA并发

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-06 10:58:41" itemprop="dateCreated datePublished" datetime="2020-03-06T10:58:41+08:00">2020-03-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 17:53:08" itemprop="dateModified" datetime="2020-03-09T17:53:08+08:00">2020-03-09</time>
              </span>
            
          

          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    <span class="post-meta-item-text">评论数：</span>
  
    <a href="/2020/03/06/JAVA并发/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/03/06/JAVA并发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-使用线程的方式"><a href="#1-使用线程的方式" class="headerlink" title="1. 使用线程的方式"></a>1. 使用线程的方式</h1><h2 id="1-1-继承Thread类"><a href="#1-1-继承Thread类" class="headerlink" title="1.1 继承Thread类"></a>1.1 继承Thread类</h2><a id="more"></a>

<p>需要重写父类的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-实现-Runnable-接口"><a href="#1-2-实现-Runnable-接口" class="headerlink" title="1.2 实现 Runnable 接口"></a>1.2 实现 Runnable 接口</h2><p>实现 Runnable 接口的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">  thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">123</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-实现-Callable接口"><a href="#1-3-实现-Callable接口" class="headerlink" title="1.3 实现 Callable接口"></a>1.3 实现 Callable接口</h2><p>实现 Callable 接口的 call() 方法，该方法有返回值，能返回一个 FutureTask 对象，可以通过 FutureTask 对象异步的获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        futureTask.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"123"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-使用线程池"><a href="#1-4-使用线程池" class="headerlink" title="1.4 使用线程池"></a>1.4 使用线程池</h2><p>使用线程池来创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">  executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 JAVA 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p>
<h2 id="2-1-新建-NEW"><a href="#2-1-新建-NEW" class="headerlink" title="2.1 新建 NEW"></a>2.1 新建 NEW</h2><p>线程被创建后尚未启动</p>
<h2 id="2-2-可运行-RUNNABLE"><a href="#2-2-可运行-RUNNABLE" class="headerlink" title="2.2 可运行 RUNNABLE"></a>2.2 可运行 RUNNABLE</h2><p>正在虚拟机中运行。但是从操作系统层面上来说，他可能处于运行状态，也可能处于等待资源调度状态。所以具体有没有运行，要看操作系统的资源调度。</p>
<h2 id="2-3-阻塞-BLOCKED"><a href="#2-3-阻塞-BLOCKED" class="headerlink" title="2.3 阻塞 BLOCKED"></a>2.3 阻塞 BLOCKED</h2><p>请求获取 monitor lock 然后进入Synchronized 函数或者代码块，但是其它的线程已经占用了该 monitor lock，因此处于阻塞状态。要结束该状态需要其它的线程释放 monitor lock。</p>
<h2 id="2-4-无期限等待-WAITING"><a href="#2-4-无期限等待-WAITING" class="headerlink" title="2.4 无期限等待 WAITING"></a>2.4 无期限等待 WAITING</h2><p>等待其他线程显式地唤醒，阻塞和等待的区别就是，阻塞是被动的，它在等待获取 monitor lock，而等待是主动的，它是调用了 Object.wait() 方法进入该状态的。</p>
<h2 id="2-5-超时等待-TIMED-WAITING"><a href="#2-5-超时等待-TIMED-WAITING" class="headerlink" title="2.5 超时等待 TIMED-WAITING"></a>2.5 超时等待 TIMED-WAITING</h2><p>它也是主动调用了 wait() 等方法，不过添加了一个时间参数，当线程等待超时后，结束等待。</p>
<h2 id="2-6-死亡-TERMINATED"><a href="#2-6-死亡-TERMINATED" class="headerlink" title="2.6 死亡 TERMINATED"></a>2.6 死亡 TERMINATED</h2><p>线程正常执行完了任务从而结束，或者产生异常导致结束。</p>
<h1 id="3-同步互斥"><a href="#3-同步互斥" class="headerlink" title="3. 同步互斥"></a>3. 同步互斥</h1><h2 id="3-1-synchronized-关键字"><a href="#3-1-synchronized-关键字" class="headerlink" title="3.1 synchronized 关键字"></a>3.1 synchronized 关键字</h2><h3 id="3-1-1-使用方式"><a href="#3-1-1-使用方式" class="headerlink" title="3.1.1 使用方式"></a>3.1.1 使用方式</h3><ol>
<li><strong>修饰实例方法</strong>：作用于当前对象实例加锁，进入同步代码前需要获得当前对象实例的锁。</li>
<li><strong>修饰静态方法</strong>：也就是给当前类加锁，会作用于类的所有实例对象，因为静态成员不属于任何一个实例对象，是类成员。</li>
<li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</li>
</ol>
<h3 id="3-1-2-synchronized-的底层原理"><a href="#3-1-2-synchronized-的底层原理" class="headerlink" title="3.1.2 synchronized 的底层原理"></a>3.1.2 synchronized 的底层原理</h3><p>因为 synchronized 是一个关键字，因此它的底层原理其实是基于 JVM 层面的。</p>
<h4 id="3-1-2-1-同步代码块的情况"><a href="#3-1-2-1-同步代码块的情况" class="headerlink" title="3.1.2.1 同步代码块的情况"></a>3.1.2.1 同步代码块的情况</h4><p><img src="/2020/03/06/JAVA并发/1.png" alt></p>
<p>由上图可以看出，synchronized 同步代码块的实现是使用的 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中<code>monitorenter</code>指向代码块的开始位置，<code>monitorexit</code> 指向的代码块结束位置。当执行<code>monitorenter</code> 指令时，线程试图获取锁也就是获取 monior（对象的对象头中的锁状态标志） 的持有权。当计数器为0，则可以获取，获取后计数器为1。再执行<code>monitorexit</code> 指令，将计数器设为0后，释放该锁。</p>
<h4 id="3-1-2-2-同步方法的情况"><a href="#3-1-2-2-同步方法的情况" class="headerlink" title="3.1.2.2 同步方法的情况"></a>3.1.2.2 同步方法的情况</h4><p><img src="/2020/03/06/JAVA并发/2.png" alt></p>
<p>同步方法中并没有 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，而是使用的<code>ACC_SYNCHRONIZED</code>标识，该标识表明了该方法是一个同步方法。</p>
<h3 id="3-1-3-synchronized-关键字的优化"><a href="#3-1-3-synchronized-关键字的优化" class="headerlink" title="3.1.3 synchronized 关键字的优化"></a>3.1.3 synchronized 关键字的优化</h3><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。</p>
<p>JDK1.6 对 synchronized 的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<h4 id="3-1-3-1-自旋锁"><a href="#3-1-3-1-自旋锁" class="headerlink" title="3.1.3.1 自旋锁"></a>3.1.3.1 自旋锁</h4><p>互斥同步进入阻塞状态的开销很大，应该尽量避免线程进入阻塞状态。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁就是让一个线程在请求共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态而减少开销，但是他需要不停的循环，从而占用CPU时间，因此只适用于锁定状态很短的场景。</p>
<p>在 JDK 1.6 中，引入了自适应的自旋锁。自旋的次数不再固定了，而是由前一次在同一个锁上的自选次数及锁的拥有者的状态来决定。</p>
<h4 id="3-1-3-2-锁消除"><a href="#3-1-3-2-锁消除" class="headerlink" title="3.1.3.2 锁消除"></a>3.1.3.2 锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当作私有数据对待，也就可以将他们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了锁，例如字符串拼接。String 是不可变的类，编译器会对 String的拼接自动优化。在 JDK 1.5 之前，会转换为 StringBuffer 对象的连续 append() 操作。</p>
<p>因为 StringBuffer 是方法都有 synchronized 关键字，所以都是同步操作。虚拟机检测到 StringBuffer 对象的动态作用域被限制在拼接方法中，其它线程无法访问到，因此可以进行锁消除。</p>
<h4 id="3-1-3-3-锁粗化"><a href="#3-1-3-3-锁粗化" class="headerlink" title="3.1.3.3 锁粗化"></a>3.1.3.3 锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>例如多个字符串的拼接，就会有 StringBuffer 的多个 append() 操作。如果虚拟机探测到这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展到整个操作序列的外部。对于多次的 append() 操作就会只加锁一次。</p>
<h4 id="3-1-3-4-偏向锁"><a href="#3-1-3-4-偏向锁" class="headerlink" title="3.1.3.4 偏向锁"></a>3.1.3.4 偏向锁</h4><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p>
<p><img src="/2020/03/06/JAVA并发/4.png" alt></p>
<p>偏向锁的思想是偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到对象头中。如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态宣告结束，此时撤销偏向后恢复到未锁定状态或者轻量级锁状态。</p>
<p><img src="/2020/03/06/JAVA并发/3.png" alt></p>
<h4 id="3-1-3-5-轻量级锁"><a href="#3-1-3-5-轻量级锁" class="headerlink" title="3.1.3.5 轻量级锁"></a>3.1.3.5 轻量级锁</h4><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<p><img src="/2020/03/06/JAVA并发/5.png" alt></p>
<p>轻量级锁是相对于重量级锁而言的，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于大部分锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量来进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了在改用互斥量来同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象处于未锁定状态，此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该锁对象处于轻量级锁状态。</p>
<p><img src="/2020/03/06/JAVA并发/6.png" alt></p>
<p>如果 CAS 操作失败了，虚拟机首先检测对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了锁对象，那么直接进行同步操作，否则说明这个锁对象已经被其它对象占用了。如果有两条以上的线程争抢同一个锁，那么该锁膨胀为重量级锁。</p>
<h2 id="3-2-ReentrantLock"><a href="#3-2-ReentrantLock" class="headerlink" title="3.2 ReentrantLock"></a>3.2 ReentrantLock</h2><h3 id="3-2-1-使用方法"><a href="#3-2-1-使用方法" class="headerlink" title="3.2.1 使用方法"></a>3.2.1 使用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"locking"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"unlocking"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-Reentrantlock-与-synchronized-的区别"><a href="#3-2-2-Reentrantlock-与-synchronized-的区别" class="headerlink" title="3.2.2 Reentrantlock 与 synchronized 的区别"></a>3.2.2 Reentrantlock 与 synchronized 的区别</h3><h4 id="3-2-2-1-实现"><a href="#3-2-2-1-实现" class="headerlink" title="3.2.2.1 实现"></a>3.2.2.1 实现</h4><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<h4 id="3-2-2-2-可重入锁"><a href="#3-2-2-2-可重入锁" class="headerlink" title="3.2.2.2 可重入锁"></a>3.2.2.2 可重入锁</h4><p>ReentrantLock 与 synchronized 关键字一样，都是可重入锁。可重入锁就是：自己可以再次获得自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁时，还是可以获取的，如果不可重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都会自增1，当计数器为0时，才释放锁。</p>
<h4 id="3-2-2-3-等待可中断"><a href="#3-2-2-3-等待可中断" class="headerlink" title="3.2.2.3 等待可中断"></a>3.2.2.3 等待可中断</h4><p>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<h4 id="3-2-3-4-公平锁与非公平锁"><a href="#3-2-3-4-公平锁与非公平锁" class="headerlink" title="3.2.3.4 公平锁与非公平锁"></a>3.2.3.4 公平锁与非公平锁</h4><p>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</p>
<h4 id="3-2-3-5-实现选择性通知"><a href="#3-2-3-5-实现选择性通知" class="headerlink" title="3.2.3.5 实现选择性通知"></a>3.2.3.5 实现选择性通知</h4><p>synchronized关键字与 wait() 和 notify()/notifyAll() 方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition() 方法。可以使用一个 lock 对象创建多个 condition 实例。</p>
<h4 id="3-2-3-6-性能"><a href="#3-2-3-6-性能" class="headerlink" title="3.2.3.6 性能"></a>3.2.3.6 性能</h4><p>在JDK1.6之后，synchornized有了非常大的优化，性能基本已经与reentracklock持平了。</p>
<h1 id="4-非阻塞同步"><a href="#4-非阻塞同步" class="headerlink" title="4. 非阻塞同步"></a>4. 非阻塞同步</h1><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是悲观的认为数据会被修改，因此无论数据是否被修改，都会进行加锁操作。</p>
<p>而非阻塞同步就是乐观锁的具体表现，总是乐观的认为数据不会被修改，但是在修改数据之前会与期望的数据进行比较，如果相同就执行，如果不同则采取补偿措施（不断地重试，直到成功为止）。</p>
<h2 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4.1 CAS"></a>4.1 CAS</h2><p>比较并交换（Compare-and-Swap，CAS），CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B</p>
<h2 id="4-2-ABA-问题"><a href="#4-2-ABA-问题" class="headerlink" title="4.2 ABA 问题"></a>4.2 ABA 问题</h2><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制<strong>变量值的版本</strong>来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h1 id="5-无同步方案"><a href="#5-无同步方案" class="headerlink" title="5. 无同步方案"></a>5. 无同步方案</h1><p>要保证线程安全，并不是一定要进行同步。如果一个方法本来就不涉及临界资源，那么它也就不需要进行同步操作了。</p>
<h2 id="5-1-栈封闭"><a href="#5-1-栈封闭" class="headerlink" title="5.1 栈封闭"></a>5.1 栈封闭</h2><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<h2 id="5-2-Thread-Local"><a href="#5-2-Thread-Local" class="headerlink" title="5.2 Thread Local"></a>5.2 Thread Local</h2><p>正常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想要实现线程拥有自己专属的本地变量，就需要使用 ThreadLocal 类了。ThreadLocal 类主要解决的就是让每个线程绑定自己的值，可以将 ThreadLocal 类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本</p>
<h3 id="5-2-1ThreadLocal-底层结构"><a href="#5-2-1ThreadLocal-底层结构" class="headerlink" title="5.2.1ThreadLocal 底层结构"></a>5.2.1ThreadLocal 底层结构</h3><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<p><img src="/2020/03/06/JAVA并发/7.png" alt></p>
<h3 id="5-2-2-内存泄漏问题"><a href="#5-2-2-内存泄漏问题" class="headerlink" title="5.2.2 内存泄漏问题"></a>5.2.2 内存泄漏问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法。</p>
<h1 id="6-JAVA-内存模型"><a href="#6-JAVA-内存模型" class="headerlink" title="6. JAVA 内存模型"></a>6. JAVA 内存模型</h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h2 id="6-1-主内存与工作内存"><a href="#6-1-主内存与工作内存" class="headerlink" title="6.1 主内存与工作内存"></a>6.1 主内存与工作内存</h2><p>Java的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<p><img src="/2020/03/06/JAVA并发/8.png" alt></p>
<h2 id="6-2-可见性"><a href="#6-2-可见性" class="headerlink" title="6.2 可见性"></a>6.2 可见性</h2><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<p>对于一个 i++ 操作，就算使用了 volatile 修饰，也无法解决线程安全问题，因为 volatile 不能保证操作的原子性。</p>
<h2 id="6-3-指令重排"><a href="#6-3-指令重排" class="headerlink" title="6.3 指令重排"></a>6.3 指令重排</h2><p>在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h1 id="7-AQS"><a href="#7-AQS" class="headerlink" title="7. AQS"></a>7. AQS</h1><p>队里同步器（AbstractQueuedSynchronizer，AQS），是一个用来构建锁和同步器的框架，使用AQS 能简单且高效的构造同步器。</p>
<h2 id="7-1-AQS-原理"><a href="#7-1-AQS-原理" class="headerlink" title="7.1 AQS 原理"></a>7.1 AQS 原理</h2><p>AQS 的核心思想就是，如果被请求的共享资源处于空闲状态，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态。如果请求的共享资源处于锁定状态，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制在 AQS 中是使用 CLH 队列锁实现的，将获取不到锁的线程加入到队列i中。</p>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p><img src="/2020/03/06/JAVA并发/9.png" alt></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-AQS底层使用了模板方法模式"><a href="#7-2-AQS底层使用了模板方法模式" class="headerlink" title="7.2  AQS底层使用了模板方法模式"></a>7.2  AQS底层使用了模板方法模式</h2><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样：</p>
<ol>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<h2 id="7-3-AQS-组件"><a href="#7-3-AQS-组件" class="headerlink" title="7.3 AQS 组件"></a>7.3 AQS 组件</h2><h3 id="7-3-1-CountDownLatch"><a href="#7-3-1-CountDownLatch" class="headerlink" title="7.3.1 CountDownLatch"></a>7.3.1 CountDownLatch</h3><p>用来控制一个或者多个线程等待多个线程。维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<h3 id="7-3-2-CyclicBarrier"><a href="#7-3-2-CyclicBarrier" class="headerlink" title="7.3.2 CyclicBarrier"></a>7.3.2 CyclicBarrier</h3><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<h3 id="7-3-3-Semaphore"><a href="#7-3-3-Semaphore" class="headerlink" title="7.3.3 Semaphore"></a>7.3.3 Semaphore</h3><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<h3 id="7-3-4-FutureTask"><a href="#7-3-4-FutureTask" class="headerlink" title="7.3.4 FutureTask"></a>7.3.4 FutureTask</h3><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<h3 id="7-3-5-ForkJoin"><a href="#7-3-5-ForkJoin" class="headerlink" title="7.3.5 ForkJoin"></a>7.3.5 ForkJoin</h3><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>
<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p>
<h3 id="7-3-6-BlockingQueue"><a href="#7-3-6-BlockingQueue" class="headerlink" title="7.3.6 BlockingQueue"></a>7.3.6 BlockingQueue</h3><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li><strong>优先级队列</strong> ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
<h1 id="8-线程池"><a href="#8-线程池" class="headerlink" title="8. 线程池"></a>8. 线程池</h1><p>线程池提供了一种限制和管理资源（包括执行一个任务）。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>使用线程池的好处：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等待线程创建就执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</li>
</ul>
<h2 id="8-1-Executor-结构"><a href="#8-1-Executor-结构" class="headerlink" title="8.1 Executor 结构"></a>8.1 Executor 结构</h2><h3 id="8-1-1-任务（Runnable-Callable）"><a href="#8-1-1-任务（Runnable-Callable）" class="headerlink" title="8.1.1 任务（Runnable/Callable）"></a>8.1.1 任务（Runnable/Callable）</h3><p>执行的任务需要实现 Runnable 接口或 Callable 接口。</p>
<h3 id="8-1-2-任务的执行（Executor，线程池）"><a href="#8-1-2-任务的执行（Executor，线程池）" class="headerlink" title="8.1.2 任务的执行（Executor，线程池）"></a>8.1.2 任务的执行（Executor，线程池）</h3><p><img src="/2020/03/06/JAVA并发/10.png" alt></p>
<h3 id="8-1-3-异步计算的结果（Future）"><a href="#8-1-3-异步计算的结果（Future）" class="headerlink" title="8.1.3 异步计算的结果（Future）"></a>8.1.3 异步计算的结果（Future）</h3><p><code>Future</code>接口以及 <code>Future</code> 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。</p>
<p>当我们把 <code>Runnable接口</code> 或 <code>Callable 接口</code> 的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。（调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask*</code> 对象）</p>
<h2 id="8-2-Executor-的使用示意图"><a href="#8-2-Executor-的使用示意图" class="headerlink" title="8.2 Executor 的使用示意图"></a>8.2 Executor 的使用示意图</h2><p><img src="/2020/03/06/JAVA并发/11.png" alt></p>
<ol>
<li>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</li>
<li>把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li>如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li>最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li>
</ol>
<h2 id="8-3-ThreadPoolExecutor-类"><a href="#8-3-ThreadPoolExecutor-类" class="headerlink" title="8.3 ThreadPoolExecutor 类"></a>8.3 ThreadPoolExecutor 类</h2><p><code>ThreadPoolExecutor</code> 类中提供了四个构造方法。可以来看最长的那个，因为其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">                         )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">      keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">  <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">  <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">  <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">  <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">  <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-1-拒绝策略"><a href="#8-3-1-拒绝策略" class="headerlink" title="8.3.1 拒绝策略"></a>8.3.1 拒绝策略</h3><ol>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ol>
<h2 id="8-4-常见的线程池"><a href="#8-4-常见的线程池" class="headerlink" title="8.4 常见的线程池"></a>8.4 常见的线程池</h2><h3 id="8-4-1-FixedThreadPool"><a href="#8-4-1-FixedThreadPool" class="headerlink" title="8.4.1 FixedThreadPool"></a>8.4.1 FixedThreadPool</h3><p><code>FixedThreadPool</code>被称为可重用固定线程数的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads,nThreads,<span class="number">0L</span>,TimeUnit.MILLISCONDS,<span class="keyword">new</span> LinkedBlockQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都被设置为创建<code>FixedThreadPool</code>时指定的参数<code>nThreads</code>。</p>
<p>当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把<code>keepAliveTime</code>设置为0L，意味着多余的空闲线程会被立即终止</p>
<h4 id="8-4-1-1-执行过程"><a href="#8-4-1-1-执行过程" class="headerlink" title="8.4.1.1 执行过程"></a>8.4.1.1 执行过程</h4><p><img src="/2020/03/06/JAVA并发/12.png" alt></p>
<ol>
<li>如果当前运行的线程数小于 <code>corePoolSize</code>， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 <code>corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li>
<li>线程池中的线程执行完手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="8-4-1-2-FixedThreadPool-的缺点"><a href="#8-4-1-2-FixedThreadPool-的缺点" class="headerlink" title="8.4.1.2 FixedThreadPool 的缺点"></a>8.4.1.2 FixedThreadPool 的缺点</h4><p><code>FixedThreadPool</code>使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 <code>Intger.MAX_VALUE</code>）作为线程池的工作队列会对线程池带来如下影响：</p>
<ol>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code>；</li>
<li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li>
<li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>
<h3 id="8-4-2-SingleThreadExecutor"><a href="#8-4-2-SingleThreadExecutor" class="headerlink" title="8.4.2 SingleThreadExecutor"></a>8.4.2 SingleThreadExecutor</h3><p>SingleThreadExecutor是使用单个worker线程的Executor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0L</span>,TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SingleThreadExecutor</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>被设置为1，其他参数与<code>FixedThreadPool</code>相同，<code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlocking-Queue</code>作为线程池的工作队列（队列的容量为<code>Integer.MAX_VALUE</code>）。<code>SingleThreadExecutor</code>使用无界队列作为工作队列对线程池带来的影响与<code>FixedThreadPool</code>相同。</p>
<h4 id="8-4-2-1-执行过程"><a href="#8-4-2-1-执行过程" class="headerlink" title="8.4.2.1 执行过程"></a>8.4.2.1 执行过程</h4><p><img src="/2020/03/06/JAVA并发/13.png" alt></p>
<ol>
<li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li>
<li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li>
<li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="8-4-2-2-SingleThreadExecutor-的缺点"><a href="#8-4-2-2-SingleThreadExecutor-的缺点" class="headerlink" title="8.4.2.2 SingleThreadExecutor 的缺点"></a>8.4.2.2 SingleThreadExecutor 的缺点</h4><p><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 <code>Intger.MAX_VALUE</code>）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM。</p>
<h3 id="8-4-3-CachedThreadPool"><a href="#8-4-3-CachedThreadPool" class="headerlink" title="8.4.3 CachedThreadPool"></a>8.4.3 CachedThreadPool</h3><p><code>CacheThreadPool</code>是一个会根据需要创建新线程的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCacheThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,<span class="number">60l</span>,TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CacheThreadPool</code>的<code>corePoolSize</code>被设置为0，即<code>corePool</code>为空；<code>maximumPoolSize</code>被设置为<code>Integer.MAX_VALUE</code>，即<code>maximumPool</code>是无界的，这里将<code>keepAliveTime</code>设置为60L，意味着<code>CacheThreadPool</code>中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将被终止。</p>
<p><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列。<code>CacheThreadPool</code>使用没有容量的<code>SynchronousQueue</code>作为线程池的工作队列，但<code>CacheThreadPool</code>的<code>maximumPool</code>是无界的。这意味着，如果主线程提交任务的速度高于<code>maximumPool</code>中线程处理任务的速度，<code>CacheThreadPool</code>将会不断创建新线程。极端情况下，<code>CacheThreadPool</code>会因为创建过多的线程而耗尽CPU和内部资源。</p>
<h4 id="8-4-3-1-执行过程"><a href="#8-4-3-1-执行过程" class="headerlink" title="8.4.3.1 执行过程"></a>8.4.3.1 执行过程</h4><p><img src="/2020/03/06/JAVA并发/14.png" alt></p>
<ol>
<li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li>
<li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，<code>execute()</code>方法执行完成；</li>
</ol>
<h4 id="8-4-3-2-CachedThreadPool-的缺点"><a href="#8-4-3-2-CachedThreadPool-的缺点" class="headerlink" title="8.4.3.2 CachedThreadPool 的缺点"></a>8.4.3.2 CachedThreadPool 的缺点</h4><p><code>CachedThreadPool</code>允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">CyC2018/CS-Notes</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions.md" target="_blank" rel="noopener">JavaGuide</a></li>
<li>《Java 并发编程的艺术》</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2020/03/05/剑指offer-连续子数组的最大和/" rel="next" title="剑指offer-连续子数组的最大和">
                <i class="fa fa-chevron-left"></i> 剑指offer-连续子数组的最大和
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2020/03/06/剑指offer-1-n整数中1出现的次数/" rel="prev" title="剑指offer-1~n整数中1出现的次数">
                剑指offer-1~n整数中1出现的次数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
  


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/QQ图片20200223231821.jpg"
      alt="经常咕咕的菜鸡博客">
  <p class="site-author-name" itemprop="name">经常咕咕的菜鸡博客</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-使用线程的方式"><span class="nav-number">1.</span> <span class="nav-text">1. 使用线程的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-继承Thread类"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 继承Thread类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-实现-Runnable-接口"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 实现 Runnable 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-实现-Callable接口"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 实现 Callable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-使用线程池"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 使用线程池</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-线程的状态"><span class="nav-number">2.</span> <span class="nav-text">2. 线程的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-新建-NEW"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 新建 NEW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-可运行-RUNNABLE"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 可运行 RUNNABLE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-阻塞-BLOCKED"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 阻塞 BLOCKED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-无期限等待-WAITING"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 无期限等待 WAITING</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-超时等待-TIMED-WAITING"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 超时等待 TIMED-WAITING</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-死亡-TERMINATED"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 死亡 TERMINATED</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-同步互斥"><span class="nav-number">3.</span> <span class="nav-text">3. 同步互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-synchronized-关键字"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 synchronized 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-使用方式"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-synchronized-的底层原理"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 synchronized 的底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-1-同步代码块的情况"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">3.1.2.1 同步代码块的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-2-同步方法的情况"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">3.1.2.2 同步方法的情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-synchronized-关键字的优化"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 synchronized 关键字的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-1-自旋锁"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">3.1.3.1 自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-2-锁消除"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">3.1.3.2 锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-3-锁粗化"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">3.1.3.3 锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-4-偏向锁"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">3.1.3.4 偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-5-轻量级锁"><span class="nav-number">3.1.3.5.</span> <span class="nav-text">3.1.3.5 轻量级锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-ReentrantLock"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-使用方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-Reentrantlock-与-synchronized-的区别"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 Reentrantlock 与 synchronized 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-1-实现"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">3.2.2.1 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-2-可重入锁"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">3.2.2.2 可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-3-等待可中断"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">3.2.2.3 等待可中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-4-公平锁与非公平锁"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">3.2.3.4 公平锁与非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-5-实现选择性通知"><span class="nav-number">3.2.2.5.</span> <span class="nav-text">3.2.3.5 实现选择性通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-6-性能"><span class="nav-number">3.2.2.6.</span> <span class="nav-text">3.2.3.6 性能</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-非阻塞同步"><span class="nav-number">4.</span> <span class="nav-text">4. 非阻塞同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-CAS"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 CAS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-ABA-问题"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 ABA 问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-无同步方案"><span class="nav-number">5.</span> <span class="nav-text">5. 无同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-栈封闭"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 栈封闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Thread-Local"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 Thread Local</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1ThreadLocal-底层结构"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1ThreadLocal 底层结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-内存泄漏问题"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 内存泄漏问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-JAVA-内存模型"><span class="nav-number">6.</span> <span class="nav-text">6. JAVA 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-主内存与工作内存"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 主内存与工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-可见性"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-指令重排"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 指令重排</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-AQS"><span class="nav-number">7.</span> <span class="nav-text">7. AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-AQS-原理"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 AQS 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-AQS底层使用了模板方法模式"><span class="nav-number">7.2.</span> <span class="nav-text">7.2  AQS底层使用了模板方法模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-AQS-组件"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 AQS 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-CountDownLatch"><span class="nav-number">7.3.1.</span> <span class="nav-text">7.3.1 CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-CyclicBarrier"><span class="nav-number">7.3.2.</span> <span class="nav-text">7.3.2 CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-Semaphore"><span class="nav-number">7.3.3.</span> <span class="nav-text">7.3.3 Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-FutureTask"><span class="nav-number">7.3.4.</span> <span class="nav-text">7.3.4 FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-5-ForkJoin"><span class="nav-number">7.3.5.</span> <span class="nav-text">7.3.5 ForkJoin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-6-BlockingQueue"><span class="nav-number">7.3.6.</span> <span class="nav-text">7.3.6 BlockingQueue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-线程池"><span class="nav-number">8.</span> <span class="nav-text">8. 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-Executor-结构"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 Executor 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-任务（Runnable-Callable）"><span class="nav-number">8.1.1.</span> <span class="nav-text">8.1.1 任务（Runnable/Callable）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-任务的执行（Executor，线程池）"><span class="nav-number">8.1.2.</span> <span class="nav-text">8.1.2 任务的执行（Executor，线程池）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-异步计算的结果（Future）"><span class="nav-number">8.1.3.</span> <span class="nav-text">8.1.3 异步计算的结果（Future）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Executor-的使用示意图"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 Executor 的使用示意图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-ThreadPoolExecutor-类"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 ThreadPoolExecutor 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-拒绝策略"><span class="nav-number">8.3.1.</span> <span class="nav-text">8.3.1 拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-常见的线程池"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 常见的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-1-FixedThreadPool"><span class="nav-number">8.4.1.</span> <span class="nav-text">8.4.1 FixedThreadPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-1-1-执行过程"><span class="nav-number">8.4.1.1.</span> <span class="nav-text">8.4.1.1 执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-1-2-FixedThreadPool-的缺点"><span class="nav-number">8.4.1.2.</span> <span class="nav-text">8.4.1.2 FixedThreadPool 的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-2-SingleThreadExecutor"><span class="nav-number">8.4.2.</span> <span class="nav-text">8.4.2 SingleThreadExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-2-1-执行过程"><span class="nav-number">8.4.2.1.</span> <span class="nav-text">8.4.2.1 执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-2-2-SingleThreadExecutor-的缺点"><span class="nav-number">8.4.2.2.</span> <span class="nav-text">8.4.2.2 SingleThreadExecutor 的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-3-CachedThreadPool"><span class="nav-number">8.4.3.</span> <span class="nav-text">8.4.3 CachedThreadPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-3-1-执行过程"><span class="nav-number">8.4.3.1.</span> <span class="nav-text">8.4.3.1 执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-3-2-CachedThreadPool-的缺点"><span class="nav-number">8.4.3.2.</span> <span class="nav-text">8.4.3.2 CachedThreadPool 的缺点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">经常咕咕的菜鸡博客</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/reading_progress/reading_progress.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>






  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


    
<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://123.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/03/06/JAVA并发/";
    this.page.identifier = "2020/03/06/JAVA并发/";
    this.page.title = 'JAVA并发';};
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://123.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
  
</script>

</body>
</html>
